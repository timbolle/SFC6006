[
  {
    "objectID": "labs/Semaine3.html",
    "href": "labs/Semaine3.html",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "",
    "text": "L‚Äôobjectif de cette semaine est de continuer √† explorer les bases du machine learning en R √† travers les possibilit√©s offertes par tidyverse.\nNous allons notamment parler de:\n\nResampling\nOptimisation d‚Äôhyperparam√®tres\nAutres fonctionnalit√©s utiles (PCA, GGally, ‚Ä¶)\n\nNous aurons besoin de plusieurs package pour cette semaine:\n\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(GGally)\n\nlibrary(doParallel)"
  },
  {
    "objectID": "labs/Semaine3.html#mod√®le-simple",
    "href": "labs/Semaine3.html#mod√®le-simple",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Mod√®le simple",
    "text": "Mod√®le simple\nLa semaine pass√©e, nous avons vu comment entra√Æner un mod√®le sur des donn√©es d‚Äôentrainement et comment tester le mod√®le sur des donn√©es de test.\nS√©paration du mod√®le:\n\nset.seed(42)\n\nsplits &lt;- initial_split(ames, prop = .75)\n\names_train &lt;- training(splits)\names_test &lt;- testing(splits)\n\nR√©glage et entrainement du mod√®le :\n\nrf_model &lt;- \n  rand_forest(trees = 1000) %&gt;% \n  set_engine(\"ranger\") %&gt;% \n  set_mode(\"regression\")\n\nrf_wflow &lt;- \n  workflow() %&gt;% \n  add_formula(\n    Sale_Price ~ Neighborhood + Gr_Liv_Area + Year_Built + Bldg_Type + \n      Latitude + Longitude) %&gt;% \n  add_model(rf_model) \n\nrf_fit &lt;- rf_wflow %&gt;% fit(data = ames_train)\n\nPr√©diction et √©valuation du mod√®le:\n\nrf_pred &lt;- rf_fit %&gt;%\n  predict(new_data = ames_test) %&gt;%\n  bind_cols(ames_test %&gt;% select(Sale_Price))\n\nrf_metrics &lt;- metric_set(rmse, rsq, mae) \n\nrf_pred %&gt;%\n  rf_metrics(truth = Sale_Price, estimate = .pred)\n\n# A tibble: 3 √ó 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 rmse    standard   29600.   \n2 rsq     standard       0.864\n3 mae     standard   19657.   \n\n\nEn g√©n√©ral, la r√©gle veut qu‚Äôon ne touche pas aux donn√©es de test avant l‚Äôentrainement final. Maintenant, si nous voulons estimer les performances de notre mod√®le avant de le faire sur les donn√©es de test, il n‚Äôest pas rare d‚Äôestimer les performances √† partir des donn√©es d‚Äôentrainement. Si nous essayons de mesurer les perfomances √† partir des donn√©es d‚Äôentrainement, nous voyons que nos performances estim√©es sont sup√©rieures √† celles obtenues sur les donn√©es de test.\n\nrf_pred_fit &lt;- rf_fit %&gt;%\n  predict(new_data = ames_train) %&gt;%\n  bind_cols(ames_train %&gt;% select(Sale_Price))\n\nrf_metrics &lt;- metric_set(rmse, rsq, mae) \n\nrf_pred_fit %&gt;%\n  rf_metrics(truth = Sale_Price, estimate = .pred)\n\n# A tibble: 3 √ó 3\n  .metric .estimator .estimate\n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt;\n1 rmse    standard   15825.   \n2 rsq     standard       0.965\n3 mae     standard   10332.   \n\n\nC‚Äôest ce qu‚Äôon appelle de l‚Äôoverfitting. Le mod√®le est tr√®s bon pour pr√©dire les donn√©es qu‚Äôil a vu (d‚Äôentrainement) mais n‚Äôest pas tr√®s bon pour g√©n√©raliser (moins bon en tout cas).\nPour √©viter cela, nous allons faire du resampling ou r√©√©chantillonnage en fran√ßais. L‚Äôid√©e est de d√©couper le set d‚Äôentrainement en plusieurs versions et d‚Äôentrainement le mod√®le sur chaque version. De cette mani√®re, √† l‚Äôentrainement, le mod√®le ne voit pas une seule version des donn√©es et il sera donc possible d‚Äô√©valuer directement ses capacit√©s √† g√©n√©raliser.\nIl existe plusieurs mani√®res de faire du resampling."
  },
  {
    "objectID": "labs/Semaine3.html#cross-validation",
    "href": "labs/Semaine3.html#cross-validation",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Cross-Validation",
    "text": "Cross-Validation\nUne mani√®re bien connue de faire du resampling est la cross-validation, et notamment la V-fold cross-validation. Les donn√©es s√©par√©es en V groupes (les folds). Le mod√®le sera ensuite entra√Æn√© V fois, en mettant de c√¥t√© √† chaque fois un des groupes.\nNous pouvons ainsi simplement cr√©er les folds:\n\names_folds &lt;- vfold_cv(ames_train, v = 10)\names_folds\n\n#  10-fold cross-validation \n# A tibble: 10 √ó 2\n   splits             id    \n   &lt;list&gt;             &lt;chr&gt; \n 1 &lt;split [1977/220]&gt; Fold01\n 2 &lt;split [1977/220]&gt; Fold02\n 3 &lt;split [1977/220]&gt; Fold03\n 4 &lt;split [1977/220]&gt; Fold04\n 5 &lt;split [1977/220]&gt; Fold05\n 6 &lt;split [1977/220]&gt; Fold06\n 7 &lt;split [1977/220]&gt; Fold07\n 8 &lt;split [1978/219]&gt; Fold08\n 9 &lt;split [1978/219]&gt; Fold09\n10 &lt;split [1978/219]&gt; Fold10"
  },
  {
    "objectID": "labs/Semaine3.html#validation-set",
    "href": "labs/Semaine3.html#validation-set",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Validation set",
    "text": "Validation set\nDans les cas o√π nous avons beaucoup d‚Äô√©chantillons, nous pouvons directement cr√©er 3 jeux de donn√©es: un jeu d‚Äôentra√Ænement, un jeu de validation et un jeu de test final. Dans ce cas, la s√©paration est faite directement avec la fonction initial_validation_split au lieu de initial_split.\n\names_val_split &lt;- initial_validation_split(ames, prop = c(0.6, 0.2))\names_val_split\n\n&lt;Training/Validation/Testing/Total&gt;\n&lt;1758/586/586/2930&gt;\n\names_val_train &lt;- training(ames_val_split)\names_val_validation &lt;- validation_set(ames_val_split)\names_val_test &lt;- testing(ames_val_split)"
  },
  {
    "objectID": "labs/Semaine3.html#bootstraping",
    "href": "labs/Semaine3.html#bootstraping",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Bootstraping",
    "text": "Bootstraping\nUne autre m√©thode connue est le Bootstrapping, qui fonctionne un peu comme la cross-validation, sans r√©duire le nombre d‚Äô√©chantillons pour l‚Äôentra√Ænement. Pour cela, √† chaque it√©ration, des √©chantillons sont mis de c√¥t√© pour estimer les performances du mod√®le mais des √©chantillons sont tir√©s al√©atoirement parmis les restant, avec remise, pour conserver la m√™me taille de jeu d‚Äôentra√Ænement. Cette m√©thode est particuli√®rement utile si le jeu de donn√©es est faible.\n\nbootstraps(ames_train, times = 5)\n\n# Bootstrap sampling \n# A tibble: 5 √ó 2\n  splits             id        \n  &lt;list&gt;             &lt;chr&gt;     \n1 &lt;split [2197/825]&gt; Bootstrap1\n2 &lt;split [2197/810]&gt; Bootstrap2\n3 &lt;split [2197/823]&gt; Bootstrap3\n4 &lt;split [2197/802]&gt; Bootstrap4\n5 &lt;split [2197/801]&gt; Bootstrap5"
  },
  {
    "objectID": "labs/Semaine3.html#estimation-des-performances",
    "href": "labs/Semaine3.html#estimation-des-performances",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Estimation des performances",
    "text": "Estimation des performances\nPour estimer les perfomances du mod√®le, il faudra faire un fit pour chaque r√©√©chantillonnage.\nPour cela, il faut utiliser la fonction fit_resamples √† la place de la fonction fit.\n\n# Avec une v-fold cross-validation\names_folds &lt;- vfold_cv(ames_train, v = 10)\n\nrf_fit_resample &lt;- rf_wflow %&gt;%\n  fit_resamples(resamples = ames_folds)\n\nrf_fit_resample\n\n# Resampling results\n# 10-fold cross-validation \n# A tibble: 10 √ó 4\n   splits             id     .metrics         .notes          \n   &lt;list&gt;             &lt;chr&gt;  &lt;list&gt;           &lt;list&gt;          \n 1 &lt;split [1977/220]&gt; Fold01 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n 2 &lt;split [1977/220]&gt; Fold02 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n 3 &lt;split [1977/220]&gt; Fold03 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n 4 &lt;split [1977/220]&gt; Fold04 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n 5 &lt;split [1977/220]&gt; Fold05 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n 6 &lt;split [1977/220]&gt; Fold06 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n 7 &lt;split [1977/220]&gt; Fold07 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n 8 &lt;split [1978/219]&gt; Fold08 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n 9 &lt;split [1978/219]&gt; Fold09 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n10 &lt;split [1978/219]&gt; Fold10 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt;\n\n\nDans le r√©sultat, on retrouve un tableau donc chaque ligne correspond √† un des folds. Les valeurs pour .metrics sont des elles-m√™mes des tableaux contenant les m√©triques obtenues pour chaque entrainement. Comme vous le voyez, par d√©faut, les pr√©dictions ne sont pas toutes retourn√©es. Pour les obtenir, il faut l‚Äôindiquer:\n\nrf_fit_resample &lt;- rf_wflow %&gt;%\n  fit_resamples(resamples = ames_folds, \n                control = control_resamples(save_pred = TRUE))\n\nrf_fit_resample\n\n# Resampling results\n# 10-fold cross-validation \n# A tibble: 10 √ó 5\n   splits             id     .metrics         .notes           .predictions\n   &lt;list&gt;             &lt;chr&gt;  &lt;list&gt;           &lt;list&gt;           &lt;list&gt;      \n 1 &lt;split [1977/220]&gt; Fold01 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n 2 &lt;split [1977/220]&gt; Fold02 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n 3 &lt;split [1977/220]&gt; Fold03 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n 4 &lt;split [1977/220]&gt; Fold04 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n 5 &lt;split [1977/220]&gt; Fold05 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n 6 &lt;split [1977/220]&gt; Fold06 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n 7 &lt;split [1977/220]&gt; Fold07 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n 8 &lt;split [1978/219]&gt; Fold08 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n 9 &lt;split [1978/219]&gt; Fold09 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n10 &lt;split [1978/219]&gt; Fold10 &lt;tibble [2 √ó 4]&gt; &lt;tibble [0 √ó 3]&gt; &lt;tibble&gt;    \n\n\nPour obtenir les estimations des performances:\n\n# Pour avoir une moyenne sur les folds\ncollect_metrics(rf_fit_resample)\n\n# A tibble: 2 √ó 6\n  .metric .estimator      mean     n   std_err .config             \n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;               \n1 rmse    standard   31491.       10 754.      Preprocessor1_Model1\n2 rsq     standard       0.845    10   0.00710 Preprocessor1_Model1\n\n# Pour avoir toutes les valeurs\ncollect_metrics(rf_fit_resample, summarize = FALSE)\n\n# A tibble: 20 √ó 5\n   id     .metric .estimator .estimate .config             \n   &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               \n 1 Fold01 rmse    standard   30567.    Preprocessor1_Model1\n 2 Fold01 rsq     standard       0.850 Preprocessor1_Model1\n 3 Fold02 rmse    standard   29891.    Preprocessor1_Model1\n 4 Fold02 rsq     standard       0.861 Preprocessor1_Model1\n 5 Fold03 rmse    standard   33102.    Preprocessor1_Model1\n 6 Fold03 rsq     standard       0.860 Preprocessor1_Model1\n 7 Fold04 rmse    standard   31229.    Preprocessor1_Model1\n 8 Fold04 rsq     standard       0.794 Preprocessor1_Model1\n 9 Fold05 rmse    standard   34911.    Preprocessor1_Model1\n10 Fold05 rsq     standard       0.853 Preprocessor1_Model1\n11 Fold06 rmse    standard   28017.    Preprocessor1_Model1\n12 Fold06 rsq     standard       0.816 Preprocessor1_Model1\n13 Fold07 rmse    standard   34180.    Preprocessor1_Model1\n14 Fold07 rsq     standard       0.844 Preprocessor1_Model1\n15 Fold08 rmse    standard   29911.    Preprocessor1_Model1\n16 Fold08 rsq     standard       0.861 Preprocessor1_Model1\n17 Fold09 rmse    standard   29141.    Preprocessor1_Model1\n18 Fold09 rsq     standard       0.850 Preprocessor1_Model1\n19 Fold10 rmse    standard   33963.    Preprocessor1_Model1\n20 Fold10 rsq     standard       0.859 Preprocessor1_Model1\n\n\nPour obtenir les pr√©dictions moyennes:\n\nrf_pred_resample &lt;- collect_predictions(rf_fit_resample, summarize = TRUE)\n\nrf_pred_resample\n\n# A tibble: 2,197 √ó 4\n     .pred  .row Sale_Price .config             \n     &lt;dbl&gt; &lt;int&gt;      &lt;int&gt; &lt;chr&gt;               \n 1 139652.     1     165000 Preprocessor1_Model1\n 2 113071.     2      91500 Preprocessor1_Model1\n 3 179712.     3     200000 Preprocessor1_Model1\n 4 183379.     4     185900 Preprocessor1_Model1\n 5 160649.     5     100000 Preprocessor1_Model1\n 6 130576.     6     149500 Preprocessor1_Model1\n 7 328024.     7     383970 Preprocessor1_Model1\n 8 128247.     8     135000 Preprocessor1_Model1\n 9 122449.     9     115500 Preprocessor1_Model1\n10 225731.    10     302000 Preprocessor1_Model1\n# ‚Ñπ 2,187 more rows\n\n\nFaites attention qu‚Äô√† cette √©tape, il s‚Äôagit des pr√©dictions sur les donn√©es d‚Äôentra√Ænement !\nPour plus d‚Äôinformations sur le resampling, vous pouvez lire ce chapitre (Kuhn and Silge, 2022)."
  },
  {
    "objectID": "labs/Semaine3.html#pr√©paration-des-donn√©es",
    "href": "labs/Semaine3.html#pr√©paration-des-donn√©es",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Pr√©paration des donn√©es",
    "text": "Pr√©paration des donn√©es\nLes donn√©es peuvent √™tre charg√©es directement √† partir de R\n\ndata(\"diamonds\")\n\ndim(diamonds)\n\n[1] 53940    10\n\n\nNous voyons qu‚Äôil y a beaucoup de donn√©es. Pour acc√©lerer les calculs dans cet exemple, nous allons prendre seulement 10% du jeu de donn√©es, et le s√©parer en ensemble d‚Äôentrainement (70%) et de test (30%). Nous allons faire un r√©√©chantillonnage en V-folds cross-validation. Nous allons cr√©er 3 folds, valeur en g√©n√©rale non recommand√©e mais que nous allons choisir pour √©viter de complexfier les calculs ici.\n\ndiamond_split &lt;- initial_split(diamonds %&gt;% sample_frac(.1), prop = .7, strata = price)\n\ndiamond_train &lt;- training(diamond_split)\ndiamond_test  &lt;- testing(diamond_split)\n\ndiamond_folds &lt;- vfold_cv(diamond_train, v = 3) # habituellement v=10"
  },
  {
    "objectID": "labs/Semaine3.html#pr√©processing",
    "href": "labs/Semaine3.html#pr√©processing",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Pr√©processing",
    "text": "Pr√©processing\nNous allons pr√©dire le price en fonction des autres variables. En regardant l‚Äô√©tendue, nous pouvons voir qu‚Äôil pourrait √™tre int√©ressant d‚Äôappliquer le log() sur cette colonne.\n\ndiamonds %&gt;% \n  reframe(price_quantile = quantile(price)) # summarise()\n\n# A tibble: 5 √ó 1\n  price_quantile\n           &lt;dbl&gt;\n1           326 \n2           950 \n3          2401 \n4          5324.\n5         18823 \n\n\nOn peut √©galement voir que la relation entre le log(price) et le carat n‚Äôest pas lin√©aire.\n\ndiamonds %&gt;%\n  sample_frac(.1) %&gt;%\n  mutate(price=log(price)) %&gt;%\n  ggplot(aes(x=carat, y=price)) +\n  geom_point()\n\n\n\n\n\n\n\n\nDans les pr√©traitements, nous pouvons donc effectuer les step_ suivantes:\n\nrf_recipe &lt;- recipe(price ~ ., data = diamond_train) %&gt;%\n    step_log(price) %&gt;%\n    step_normalize(all_numeric_predictors()) %&gt;%\n    step_dummy(all_nominal_predictors()) %&gt;%\n    step_poly(carat, degree = 2)"
  },
  {
    "objectID": "labs/Semaine3.html#mod√®le-et-choix-des-param√®tres",
    "href": "labs/Semaine3.html#mod√®le-et-choix-des-param√®tres",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Mod√®le et choix des param√®tres",
    "text": "Mod√®le et choix des param√®tres\nPour le mod√®le, nous allons faire de la regression avec Random Forest. Cette fois, nous allons laisser les param√®tres mtry et min_n de c√¥t√© pour l‚Äôinstant pour les estimer √† partir des donn√©es.\n\nrf_model &lt;- rand_forest(mtry = tune(), trees = 1000, min_n = tune()) %&gt;%\n    set_mode(\"regression\") %&gt;%\n    set_engine(\"ranger\")\n\nNous pouvons voir l‚Äô√©tat de nos param√®tres et le range de valeurs par d√©faut.\n\nrf_param &lt;- extract_parameter_set_dials(rf_model)\n\nrf_param\n\nCollection of 2 parameters for tuning\n\n identifier  type    object\n       mtry  mtry nparam[?]\n      min_n min_n nparam[+]\n\nModel parameters needing finalization:\n   # Randomly Selected Predictors ('mtry')\n\nSee `?dials::finalize` or `?dials::update.parameters` for more information.\n\nrf_param %&gt;% extract_parameter_dials(\"mtry\")\n\n# Randomly Selected Predictors (quantitative)\nRange: [1, ?]\n\n\nIci, nous voyons que le param√®tre mtry n‚Äôest pas encore initialis√© avec un range de valeurs possibles. C‚Äôest normal car ce param√®tre se base sur le nombre de colonnes √† disposition. Nous pouvons le mettre √† jour avec la fonction finalize() en lui passant les donn√©es preprocess√©es. Pour cela, nous pouvons appliquer prep() (l‚Äô√©quivalent de fit mais pour les recettes) et juice pour obtenir les donn√©es apr√®s pr√©traitement.\n\ndiamond_train_juiced &lt;- rf_recipe %&gt;% prep(diamond_train) %&gt;% juice()\n\nrf_param_updated &lt;- rf_model %&gt;% \n  extract_parameter_set_dials() %&gt;% \n  finalize(diamond_train_juiced %&gt;% select(-price))\n\nrf_param_updated %&gt;% extract_parameter_dials(\"mtry\")\n\n# Randomly Selected Predictors (quantitative)\nRange: [1, 24]\n\n\nNous voyons que le param√®tre mtry est maintenant initialis√©."
  },
  {
    "objectID": "labs/Semaine3.html#tuning-des-param√®tres-et-grid_search",
    "href": "labs/Semaine3.html#tuning-des-param√®tres-et-grid_search",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Tuning des param√®tres et Grid_search",
    "text": "Tuning des param√®tres et Grid_search\nNous pouvons cr√©er une grille de recherche sur nos param√®tres √† partir de la fonction grid_regular. Ici level indique le nombre de valeurs que nous allons tester par paramtres. Par exemple, avec level=3, nous aurons 3 valeurs possibles pour mtry et 3 pour min_n.\n\nrf_grid &lt;- rf_param_updated %&gt;%\n  grid_regular(levels = 3)\n\nrf_grid\n\n# A tibble: 9 √ó 2\n   mtry min_n\n  &lt;int&gt; &lt;int&gt;\n1     1     2\n2    12     2\n3    24     2\n4     1    21\n5    12    21\n6    24    21\n7     1    40\n8    12    40\n9    24    40\n\n\nNous pouvons ensuite cr√©er notre workflow comme d‚Äôhabitude.\n\nrf_wf &lt;- workflow() %&gt;%\n  add_model(rf_model) %&gt;%\n  add_recipe(rf_recipe)\n\nEn revanche, au lieu de fit ou de fit_resample, nous allons tune_grid en lui pr√©cisant qu‚Äôil doit travailler avec les donn√©es r√©√©chantillonn√©es. Pour chaque r√©√©chantillonnage, il va donc tester toutes les combinaisons de param√®tres possible. Cela peut conduire √† des longs temps de calculs (c‚Äôest pourquoi nous avons r√©duit le nombre de folds, de donn√©es et de levels).\nL‚Äôobjectif ici est de trouver la meilleure combinaison de param√®tres possible. Nous devons donc √©galement indiquer des m√©triques pour estimer la performance.\nLa ligne doParallel::registerDoParallel() permet de faire travailler R en parall√®le sur plusieurs threads.\n\ndoParallel::registerDoParallel()\n\nrf_tune &lt;- rf_wf %&gt;%\n  tune_grid(diamond_folds,\n            grid = rf_grid,\n            metrics = metric_set(rmse, rsq, mae))\n\nUne fois la recherche termin√©e, nous pouvons voir les r√©sultats obtenus avec autoplot.\n\nrf_tune %&gt;% autoplot() +\n  scale_color_viridis_d()\n\n\n\n\n\n\n\n\nPlusieurs fonctions sont √† disposition pour acc√©der aux r√©sultats.\n\nrf_tune %&gt;% collect_metrics()\n\n# A tibble: 27 √ó 8\n    mtry min_n .metric .estimator   mean     n  std_err .config             \n   &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;               \n 1     1     2 mae     standard   0.289      3 0.00795  Preprocessor1_Model1\n 2     1     2 rmse    standard   0.374      3 0.00826  Preprocessor1_Model1\n 3     1     2 rsq     standard   0.931      3 0.00156  Preprocessor1_Model1\n 4    12     2 mae     standard   0.0921     3 0.00116  Preprocessor1_Model2\n 5    12     2 rmse    standard   0.124      3 0.00212  Preprocessor1_Model2\n 6    12     2 rsq     standard   0.985      3 0.000239 Preprocessor1_Model2\n 7    24     2 mae     standard   0.0922     3 0.00120  Preprocessor1_Model3\n 8    24     2 rmse    standard   0.125      3 0.00266  Preprocessor1_Model3\n 9    24     2 rsq     standard   0.985      3 0.000329 Preprocessor1_Model3\n10     1    21 mae     standard   0.297      3 0.00891  Preprocessor1_Model4\n# ‚Ñπ 17 more rows\n\nrf_tune %&gt;% show_best()\n\nWarning in show_best(.): No value of `metric` was given; \"rmse\" will be used.\n\n\n# A tibble: 5 √ó 8\n   mtry min_n .metric .estimator  mean     n std_err .config             \n  &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;               \n1    12     2 rmse    standard   0.124     3 0.00212 Preprocessor1_Model2\n2    24     2 rmse    standard   0.125     3 0.00266 Preprocessor1_Model3\n3    24    21 rmse    standard   0.130     3 0.00278 Preprocessor1_Model6\n4    12    21 rmse    standard   0.130     3 0.00189 Preprocessor1_Model5\n5    12    40 rmse    standard   0.138     3 0.00206 Preprocessor1_Model8\n\nrf_tune %&gt;% show_best(metric = \"rsq\")\n\n# A tibble: 5 √ó 8\n   mtry min_n .metric .estimator  mean     n  std_err .config             \n  &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;    &lt;dbl&gt; &lt;chr&gt;               \n1    12     2 rsq     standard   0.985     3 0.000239 Preprocessor1_Model2\n2    24     2 rsq     standard   0.985     3 0.000329 Preprocessor1_Model3\n3    24    21 rsq     standard   0.983     3 0.000378 Preprocessor1_Model6\n4    12    21 rsq     standard   0.983     3 0.000207 Preprocessor1_Model5\n5    12    40 rsq     standard   0.981     3 0.000193 Preprocessor1_Model8"
  },
  {
    "objectID": "labs/Semaine3.html#mod√®le-final",
    "href": "labs/Semaine3.html#mod√®le-final",
    "title": "Semaine3 - Machine leanring - Suite",
    "section": "Mod√®le final",
    "text": "Mod√®le final\nLa meilleure combinaison peut √™tre extraite automatiquement selon certains crit√®res avec l‚Äôensemble de fonction select_*. Ici, nous prenons la meilleure combinaison de paramptres selon la m√©trique \\(R^2\\). La fonction finalize_workflow() permet ensuite de cr√©er le workflow final avec les param√®tres s√©lectionn√©s.\n\nrf_best &lt;- rf_tune %&gt;% select_best(metric = \"rsq\")\n\nrf_final &lt;- rf_wf %&gt;% finalize_workflow(rf_best)\n\nrf_final\n\n‚ïê‚ïê Workflow ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nPreprocessor: Recipe\nModel: rand_forest()\n\n‚îÄ‚îÄ Preprocessor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n4 Recipe Steps\n\n‚Ä¢ step_log()\n‚Ä¢ step_normalize()\n‚Ä¢ step_dummy()\n‚Ä¢ step_poly()\n\n‚îÄ‚îÄ Model ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nRandom Forest Model Specification (regression)\n\nMain Arguments:\n  mtry = 12\n  trees = 1000\n  min_n = 2\n\nComputational engine: ranger \n\n\nLa fonction last_fit() permet d‚Äôentrainer une derni√®re fois le mod√®le sur les donn√©es d‚Äôentrainement et de tester les perfomances sur les donn√©es de test.\n\nfinal_pred &lt;- rf_final %&gt;% last_fit(diamond_split)\n\nNous pouvons finalement voir nos performances finales !\n\nfinal_pred %&gt;% collect_metrics()\n\n# A tibble: 2 √ó 4\n  .metric .estimator .estimate .config             \n  &lt;chr&gt;   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               \n1 rmse    standard       0.114 Preprocessor1_Model1\n2 rsq     standard       0.988 Preprocessor1_Model1\n\n\n\nfinal_pred %&gt;% \n  collect_predictions() %&gt;%\n  ggplot(aes(x=price, y=.pred)) + \n  geom_point()\n\n\n\n\n\n\n\n\nPour plus d‚Äôinformations sur le tuning d‚Äôhyperparam√®tres, vous pouvez lire les chapitre 12 et 13 (Kuhn and Silge, 2022)."
  },
  {
    "objectID": "labs/Semaine1.html",
    "href": "labs/Semaine1.html",
    "title": "Semaine 1 - Data wrangling",
    "section": "",
    "text": "En janvier 2017, Buzzfeed a publi√© un article sur pourquoi les laur√©ats du prix Nobel montrent que l‚Äôimmigration est si importante pour la science am√©ricaine.\nVous pouvez lire l‚Äôarticle ici. Dans l‚Äôarticle, ils montrent que bien que la plupart des laur√©ats vivants du prix Nobel en sciences soient bas√©s aux √âtats-Unis, beaucoup d‚Äôentre eux sont n√©s dans d‚Äôautres pays. C‚Äôest une des raisons pour lesquelles le monde scientifique dit que l‚Äôimmigration est vitale pour le progr√®s. Dans ce lab, nous travaillerons avec les donn√©es de cet article pour recr√©er certaines de leurs visualisations ainsi qu‚Äôexplorer de nouvelles questions."
  },
  {
    "objectID": "labs/Semaine1.html#√©chauffement",
    "href": "labs/Semaine1.html#√©chauffement",
    "title": "Semaine 1 - Data wrangling",
    "section": "√âchauffement",
    "text": "√âchauffement\nAvant d‚Äôintroduire les donn√©es, commen√ßons par quelques exercices simples.\n\nMettez √† jour le YAML, en changeant le nom de l‚Äôauteur par le v√¥tre, et knit le document.\nCommittez vos modifications avec un message de commit. Assurez vous que les fichiers .Rmd et .md sont bien ajout√©s au commit.\nPushez vos modifications sur GitHub.\nAllez dans votre d√©p√¥t sur GitHub et confirmez que vos modifications sont visibles dans vos fichiers Rmd et md."
  },
  {
    "objectID": "labs/Semaine1.html#packages",
    "href": "labs/Semaine1.html#packages",
    "title": "Semaine 1 - Data wrangling",
    "section": "Packages",
    "text": "Packages\nNous utiliserons le package tidyverse pour une grande partie de la manipulation des donn√©es.\n\nlibrary(tidyverse)\n\nS‚Äôil n‚Äôest pas d√©j√† install√©, vous pouvez le faire avec la commande install.packages(\"tidyverse\"). Cette commande n‚Äôest n√©caisse qu‚Äôune seule fois."
  },
  {
    "objectID": "labs/Semaine1.html#donn√©es",
    "href": "labs/Semaine1.html#donn√©es",
    "title": "Semaine 1 - Data wrangling",
    "section": "Donn√©es",
    "text": "Donn√©es\nLe jeu de donn√©es pour cet exercice se trouve sous forme de fichier CSV (valeurs s√©par√©es par des virgules) dans le dossier data de votre d√©p√¥t. Vous pouvez les charger avec la fonction read_csv:\nLes descriptions des variables sont les suivantes :\n\nid: Num√©ro d‚Äôidentification\nfirstname: Pr√©nom du laur√©at\nsurname: Nom de famille\nyear: Ann√©e de remise du prix\ncategory: Cat√©gorie du prix\naffiliation: Affiliation du laur√©at\ncity: Ville du laur√©at l‚Äôann√©e du prix\ncountry: Pays du laur√©at l‚Äôann√©e du prix\nborn_date: Date de naissance du laur√©at\ndied_date: Date de d√©c√®s du laur√©at\ngender: Sexe du laur√©at\nborn_city: Ville de naissance du laur√©at\nborn_country: Pays de naissance du laur√©at\nborn_country_code: Code du pays de naissance du laur√©at\ndied_city: Ville de d√©c√®s du laur√©at\ndied_country: Pays de d√©c√®s du laur√©at\ndied_country_code: Code du pays de d√©c√®s du laur√©at\noverall_motivation: Motivation g√©n√©rale pour la reconnaissance\nshare: Nombre d‚Äôautres laur√©ats avec lesquels le prix est partag√©\nmotivation: Motivation pour la reconnaissance\n\nDans quelques cas, le nom de la ville/pays a chang√© apr√®s la r√©ception du prix par le laur√©at (par exemple, en 1975, la Bosnie-Herz√©govine s‚Äôappelait la R√©publique f√©d√©rative socialiste de Yougoslavie). Dans ces cas, les variables ci-dessous refl√®tent un nom diff√©rent de leurs homologues sans le suffixe `_original`.\n\nborn_country_original\nborn_city_original\ndied_country_original\ndied_city_original\ncity_original\ncountry_original"
  },
  {
    "objectID": "labs/Semaine1.html#manipulation-de-donn√©es",
    "href": "labs/Semaine1.html#manipulation-de-donn√©es",
    "title": "Semaine 1 - Data wrangling",
    "section": "Manipulation de donn√©es",
    "text": "Manipulation de donn√©es\nNous allons commencer par jeter un coup d‚Äôoeil au tableau que nous avons charg√©. Pour cela, nous pouvons utiliser la fonction glimpse()\n\n\nRows: 935\nColumns: 26\n$ id                    &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 6, 8, 9, 10, 11, 12, 13, 14, 1‚Ä¶\n$ firstname             &lt;chr&gt; \"Wilhelm Conrad\", \"Hendrik A.\", \"Pieter\", \"Henri‚Ä¶\n$ surname               &lt;chr&gt; \"R√∂ntgen\", \"Lorentz\", \"Zeeman\", \"Becquerel\", \"Cu‚Ä¶\n$ year                  &lt;dbl&gt; 1901, 1902, 1902, 1903, 1903, 1903, 1911, 1904, ‚Ä¶\n$ category              &lt;chr&gt; \"Physics\", \"Physics\", \"Physics\", \"Physics\", \"Phy‚Ä¶\n$ affiliation           &lt;chr&gt; \"Munich University\", \"Leiden University\", \"Amste‚Ä¶\n$ city                  &lt;chr&gt; \"Munich\", \"Leiden\", \"Amsterdam\", \"Paris\", \"Paris‚Ä¶\n$ country               &lt;chr&gt; \"Germany\", \"Netherlands\", \"Netherlands\", \"France‚Ä¶\n$ born_date             &lt;date&gt; 1845-03-27, 1853-07-18, 1865-05-25, 1852-12-15,‚Ä¶\n$ died_date             &lt;date&gt; 1923-02-10, 1928-02-04, 1943-10-09, 1908-08-25,‚Ä¶\n$ gender                &lt;chr&gt; \"male\", \"male\", \"male\", \"male\", \"male\", \"female\"‚Ä¶\n$ born_city             &lt;chr&gt; \"Remscheid\", \"Arnhem\", \"Zonnemaire\", \"Paris\", \"P‚Ä¶\n$ born_country          &lt;chr&gt; \"Germany\", \"Netherlands\", \"Netherlands\", \"France‚Ä¶\n$ born_country_code     &lt;chr&gt; \"DE\", \"NL\", \"NL\", \"FR\", \"FR\", \"PL\", \"PL\", \"GB\", ‚Ä¶\n$ died_city             &lt;chr&gt; \"Munich\", NA, \"Amsterdam\", NA, \"Paris\", \"Sallanc‚Ä¶\n$ died_country          &lt;chr&gt; \"Germany\", \"Netherlands\", \"Netherlands\", \"France‚Ä¶\n$ died_country_code     &lt;chr&gt; \"DE\", \"NL\", \"NL\", \"FR\", \"FR\", \"FR\", \"FR\", \"GB\", ‚Ä¶\n$ overall_motivation    &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, ‚Ä¶\n$ share                 &lt;dbl&gt; 1, 2, 2, 2, 4, 4, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, ‚Ä¶\n$ motivation            &lt;chr&gt; \"\\\"in recognition of the extraordinary services ‚Ä¶\n$ born_country_original &lt;chr&gt; \"Prussia (now Germany)\", \"the Netherlands\", \"the‚Ä¶\n$ born_city_original    &lt;chr&gt; \"Lennep (now Remscheid)\", \"Arnhem\", \"Zonnemaire\"‚Ä¶\n$ died_country_original &lt;chr&gt; \"Germany\", \"the Netherlands\", \"the Netherlands\",‚Ä¶\n$ died_city_original    &lt;chr&gt; \"Munich\", NA, \"Amsterdam\", NA, \"Paris\", \"Sallanc‚Ä¶\n$ city_original         &lt;chr&gt; \"Munich\", \"Leiden\", \"Amsterdam\", \"Paris\", \"Paris‚Ä¶\n$ country_original      &lt;chr&gt; \"Germany\", \"the Netherlands\", \"the Netherlands\",‚Ä¶\n\n\nIl est ainsi possible de voir pour chaque colonne, le type de donn√©es qui a √©t√© d√©tect√© lors de l‚Äôimportation, et un coup d‚Äôoeils aux premi√®res valeurs. C‚Äôest le moment de rep√©rer si un type ne convient pas.\n\nExploration de donn√©es\nCombien d‚Äôobservations et combien de variables y a-t-il dans le jeu de donn√©es ? Que repr√©sente chaque ligne ?\n\n\nS√©lection de donn√©es\nIl y a quelques observations dans ce jeu de donn√©es que nous exclurons de notre analyse pour correspondre aux r√©sultats de Buzzfeed.\nPour rappel, les diff√©rents verbes du tidyverse permettent de manipuler les donn√©es:\n\nselect: S√©lectionner une colonne\narrange: Ordonner les lignes\nslice: S√©lectionner des lignes (par les index)\nfilter: S√©lectionner des lignes selon des crit√®res\ndistinct: Filtrer les lignes uniques\nmutate: Ajout de nouvelles variables\nsummarise: R√©duire variables en valeurs\ngroup_by: Regrouper des observations selon une variable\n\nCountez le nombre de valeur NA pour la colonne country. Pour cela, vous pouvez utiliser les fonctions filter, is.na et count.\nQuelles sont les valeurs possibles pour la variable gender ? La valeur org signifie qu‚Äôune organisation a gagn√© le prix Nobel.\nNous allons maintenant vouloir s√©lectionner seulement les entr√©es qui ont toutes les valeur n√©cessaire, c‚Äôest-√†-dire des personnes vivantes dont on connait le pays d‚Äôorigine.\nCr√©ez un nouveau data frame appel√© nobel_living qui filtre pour\n\nles laur√©ats pour lesquels country est disponible\nles laur√©ats qui sont des personnes par opposition aux organisations (les organisations sont d√©sign√©es par org dans la variable gender)\nles laur√©ats vivant, c‚Äôest-√†-dire les entr√©es dont la died_date est NA\n\nV√©rifiez que vous obtenez bien un data frame avec 228 observations apr√®s avoir filtr√© les donn√©es.\nüß∂ ‚úÖ ‚¨ÜÔ∏è Knit, commit, and push ! N‚Äôoubliez pas le message de commit.\n\n\nAnalyse et visualisation de donn√©es\n\n‚ÄúLa plupart des laur√©ats vivants du prix Nobel √©taient bas√©s aux √âtats-Unis lorsqu‚Äôils ont remport√© leurs prix‚Äù\n‚Ä¶ dit l‚Äôarticle de Buzzfeed. Voyons si c‚Äôest vrai.\nTout d‚Äôabord, nous allons cr√©er une nouvelle variable pour identifier si le laur√©at vivait aux √âtats-Unis lorsqu‚Äôil a remport√© son prix. Pour cela, nous utiliserons la fonction mutate(). Cr√©ez une nouvelle colonne country_us qui sera √©gale √† \"USA\" si le country est √©gal √† ‚ÄúUSA‚Äù et √† \"Other\" sinon. Pour cela, pensez √† utiliser la fonction if_else dans votre mutate.\nNous voudrons ensuite transformer cette colonne en facteur, ce qui est toujours utile lorsqu‚Äôon travaille avec des donn√©es cat√©goriques. Pour cela, vous pouvez utiliser la fonction fct_relvel() en pr√©cisant la colonne √† mettre en facteur et le nom des niveaux (ici ‚ÄúUSA‚Äù en premier et ‚ÄúOther‚Äù en deuxi√®me).\nPour la suite de l‚Äôexercice, nous limiterons notre analyse aux cat√©gories suivantes : Physique, M√©decine, Chimie et √âconomie.\nCr√©ez un nouveau data frame appel√© nobel_living_science qui filtre pour les cat√©gories suivantes : Physique, M√©decine, Chimie et √âconomie.\nPour cela, vous pouvez tester si category est dans le vecteur c(\"Physics\", \"Medicine\", \"Chemistry\", \"Economics\"). Profitez-en √©galement pour transformer cette colonne en facteurs √©galement, en les ordonant par ordre alphab√©tique.\nPour le prochain exercice, travaillez avec le data frame nobel_living_science que nous avons cr√©√© ci-dessus.\nCr√©ez un graphique √† barres avec des facets visualisant la relation entre la cat√©gorie du prix Nobel et si le laur√©at √©tait aux √âtats-Unis lorsqu‚Äôil l‚Äôa remport√©.\nPour rappel, les graphiques peuvent √™tre cr√©√©s de la forme:\n\nnobel_living_science %&gt;%\n  ggplot(aes(...)) +\n    geom_XXX(...)\n\nPar exemple,\n\nnobel_living_science %&gt;%\n  ggplot(aes(x=country_us, fill = country_us)) +\n  geom_bar() +\n   labs(x = \"Pays de r√©sidence\",                 # On met √† jour les labels\n       y = \"Nombre de laur√©ats\",\n       title = \"Pays de r√©sidence des laur√©ats vivants du prix Nobel\",\n       subtitle = \"Selon si le pays de r√©sidence correspond aux USA ou non\",\n       fill = \"Pays du laur√©at\")\n\n\n\n\n\n\n\n\nPour cr√©er des facettes selon les cat√©gories, vous pouvez ajouter la fonction facet_wrap. Votre visualisation doit avoir:\n\nVotre visualisation doit √™tre facett√©e par cat√©gorie.\nPour chaque facette, vous devez avoir deux barres, une pour les gagnants aux √âtats-Unis et une pour les autres.\nInversez les coordonn√©es pour que les barres soient horizontales, pas verticales.\n\n\n\n\n\n\n\n\n\n\nInterpr√©tez votre visualisation et commentez le titre de Buzzfeed en regardant s‚Äôil est soutenu par les donn√©es.\nüß∂ ‚úÖ ‚¨ÜÔ∏è Knit, commit, and push ! N‚Äôoubliez pas le message de commit.\n\n\n‚ÄúMais parmi ces laur√©ats du prix Nobel bas√©s aux √âtats-Unis, beaucoup sont n√©s dans d‚Äôautres pays‚Äù\nCr√©ez une nouvelle variable appel√©e born_country_us qui a la valeur \"USA\" si le laur√©at est n√© aux √âtats-Unis, et \"Other\" sinon. Combien de gagnants sont n√©s aux √âtats-Unis ?\nAjoutez une deuxi√®me variable √† votre visualisation de l‚Äôexercice 4 bas√©e sur si le laur√©at est n√© aux √âtats-Unis ou non. D‚Äôapr√®s votre visualisation, les donn√©es semblent-elles soutenir l‚Äôaffirmation de Buzzfeed ? Expliquez votre raisonnement en 1-2 phrases.\n\nVotre visualisation finale doit contenir une facette pour chaque cat√©gorie.\nDans chaque facette, il doit y avoir une barre pour savoir si le laur√©at a remport√© le prix aux √âtats-Unis ou non.\nChaque barre doit avoir des segments pour savoir si le laur√©at est n√© aux √âtats-Unis ou non.\n\n\n\n\n\n\n\n\n\n\nüß∂ ‚úÖ ‚¨ÜÔ∏è Knit, commit, and push ! N‚Äôoubliez pas le message de commit.\n\n\nD‚Äôo√π viennent les laur√©ats n√©s √† l‚Äô√©tranger qui ont remport√© leur prix aux √âtats-Unis ?\nDans un seul pipeline, filtrez pour les laur√©ats qui ont remport√© leur prix aux √âtats-Unis, mais qui sont n√©s en dehors des √âtats-Unis, puis cr√©ez un tableau de fr√©quence (avec la fonction count()) pour leur pays de naissance (born_country) et arrangez le data frame r√©sultant par ordre d√©croissant du nombre d‚Äôobservations pour chaque pays. Quel pays est le plus commun ?\nüß∂ ‚úÖ ‚¨ÜÔ∏è Knit, commit, and push ! N‚Äôoubliez pas le message de commit.\nMaintenant, relisez votre rapport pour vous assurer que vous avez r√©pondu √† toutes les questions et que tous vos blocs de code R sont correctement √©tiquet√©s."
  },
  {
    "objectID": "labs/Semaine1.html#int√©ress√©-par-la-fa√ßon-dont-buzzfeed-a-r√©alis√©-leurs-visualisations",
    "href": "labs/Semaine1.html#int√©ress√©-par-la-fa√ßon-dont-buzzfeed-a-r√©alis√©-leurs-visualisations",
    "title": "Semaine 1 - Data wrangling",
    "section": "Int√©ress√© par la fa√ßon dont Buzzfeed a r√©alis√© leurs visualisations ?",
    "text": "Int√©ress√© par la fa√ßon dont Buzzfeed a r√©alis√© leurs visualisations ?\nLes graphiques dans l‚Äôarticle de Buzzfeed sont appel√©s des graphiques en gaufre (waffle plots). Vous pouvez trouver le code utilis√© pour r√©aliser ces graphiques dans le d√©p√¥t GitHub de Buzzfeed (oui, ils en ont un !) ici. Vous pouvez essayer de recr√©er ces graphiques pour le plaisir, mais ce n‚Äôest pas une exigence pour ce lab."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SFC6006",
    "section": "",
    "text": "Bienvenue au module d‚Äôanalyse de donn√©es en R du cours SFC6006 !\nL‚Äôensemble des ressources pour les cours se trouvent sur ce site web.\n\n\nL‚Äôensemble de ce site est sous license a Creative Commons Attribution-ShareAlike 4.0 International.\n\n\n\nUne partie du cours propos√© ici est adapt√© du mat√©riel propos√© par Data Science in a Box.\nThis website is built with Quarto."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "SFC6006",
    "section": "",
    "text": "L‚Äôensemble de ce site est sous license a Creative Commons Attribution-ShareAlike 4.0 International."
  },
  {
    "objectID": "index.html#acknowledements",
    "href": "index.html#acknowledements",
    "title": "SFC6006",
    "section": "",
    "text": "Une partie du cours propos√© ici est adapt√© du mat√©riel propos√© par Data Science in a Box.\nThis website is built with Quarto."
  },
  {
    "objectID": "slides/00 - Intro.html#objectifs",
    "href": "slides/00 - Intro.html#objectifs",
    "title": "01 - Introduction",
    "section": "Objectifs",
    "text": "Objectifs\n√ätre capable de manipuler des donn√©es et de les visualiser avec R (SFC1018)\n√àtre capable de mettre en oeuvre des m√©thodes de traitement statistique des donn√©es avec R (SFC6008)\n√ätre capable de r√©aliser un projet de traitement de donn√©es de A √† Z en R."
  },
  {
    "objectID": "slides/00 - Intro.html#m√©thode",
    "href": "slides/00 - Intro.html#m√©thode",
    "title": "01 - Introduction",
    "section": "M√©thode",
    "text": "M√©thode\n\n(Wickham et al., 2023)"
  },
  {
    "objectID": "slides/00 - Intro.html#ressources",
    "href": "slides/00 - Intro.html#ressources",
    "title": "01 - Introduction",
    "section": "Ressources",
    "text": "Ressources\n\n\n\n(Wickham et al., 2023)\n\n\n(Kuhn and Silge, 2022)"
  },
  {
    "objectID": "slides/00 - Intro.html#les-outils",
    "href": "slides/00 - Intro.html#les-outils",
    "title": "01 - Introduction",
    "section": "Les outils",
    "text": "Les outils\n\nD√©veloppement:\n\nR\nRStudio\ntidyverse\ntidymodels\nR Markdown\n\n\n\nGestion et collaboration:\n\nGit\nGitHub"
  },
  {
    "objectID": "slides/00 - Intro.html#objectifs-1",
    "href": "slides/00 - Intro.html#objectifs-1",
    "title": "01 - Introduction",
    "section": "Objectifs",
    "text": "Objectifs\n\n\nAnalyser des donn√©es\nAnalyser des donn√©es de mani√®re r√©p√©table\nAnalyser des donn√©es de mani√®re r√©p√©table, avec des outils de programmation modernes\nAnalyser des donn√©es de mani√®re r√©p√©table et collaborative, avec des outils de programmation modernes"
  },
  {
    "objectID": "slides/00 - Intro.html#r√©p√©tabilit√©",
    "href": "slides/00 - Intro.html#r√©p√©tabilit√©",
    "title": "01 - Introduction",
    "section": "R√©p√©tabilit√©",
    "text": "R√©p√©tabilit√©\n\nQue signifie conduire une analyse de donn√©e de mani√®re r√©p√©table ?\n\n√Ä court-terme:\n\nPouvons nous reproduire les tableaux et les figures √† partir des donn√©es\nEst-ce que le code fait ce que nous voulons ?\nPouvons-nous reconstruire pourquoi et comment nous avons obtenus les r√©sultats\n\n√Ä long-terme:\n\nPeut-on r√©utiliser le code pour d‚Äôautres donn√©es ?\nPeut-on r√©utiliser le code pour faire autre chose ?"
  },
  {
    "objectID": "slides/00 - Intro.html#les-outils-de-la-r√©p√©rabilit√©",
    "href": "slides/00 - Intro.html#les-outils-de-la-r√©p√©rabilit√©",
    "title": "01 - Introduction",
    "section": "Les outils de la r√©p√©rabilit√©",
    "text": "Les outils de la r√©p√©rabilit√©\nScriptability \\(\\rightarrow\\) R\nDocumentation et communication \\(\\rightarrow\\) R Markdown\nGestion et collaboration \\(\\rightarrow\\) Git/GitHub"
  },
  {
    "objectID": "slides/00 - Intro.html#r-et-rstudio",
    "href": "slides/00 - Intro.html#r-et-rstudio",
    "title": "01 - Introduction",
    "section": "R et RStudio",
    "text": "R et RStudio\n\n\n\n\nR est un language de programmation open-source\nR est un environnement pour faire des calculs statistiques et de la visualisation\nDe nombreuses autres applications sont disponibles gr√¢ce √† des packages\n\n\n\n\nRStudio est un IDE (Environnement de D√©veloppement Int√©gr√©)\nC‚Äôest une interface pour R\nPas n√©cessaire pour coder en R mais tellement pratique !"
  },
  {
    "objectID": "slides/00 - Intro.html#rstudio-tour",
    "href": "slides/00 - Intro.html#rstudio-tour",
    "title": "01 - Introduction",
    "section": "RStudio tour",
    "text": "RStudio tour"
  },
  {
    "objectID": "slides/00 - Intro.html#r-packages",
    "href": "slides/00 - Intro.html#r-packages",
    "title": "01 - Introduction",
    "section": "R packages",
    "text": "R packages\nLes packages sont les building blocks de la reproductibilit√©. Ils contiennent de nombreuses fonctions r√©utilisables, de la documentation et donn√©es de test (Wickham and Bryan, 2023)\nNous allons en utiliser quelques une mais vous verrez que c‚Äôest tout une philosophie !"
  },
  {
    "objectID": "slides/00 - Intro.html#tidyverse",
    "href": "slides/00 - Intro.html#tidyverse",
    "title": "01 - Introduction",
    "section": "Tidyverse",
    "text": "Tidyverse\n\n\n\n\ntidyverse.org\nLe Tidyverse est une collection de packages d√©velopp√©s pour faire de la data science\nIl y a une philophie et une grammaire commune √† tous ces packages, que nous allons apprendre."
  },
  {
    "objectID": "slides/00 - Intro.html#tidymodels",
    "href": "slides/00 - Intro.html#tidymodels",
    "title": "01 - Introduction",
    "section": "Tidymodels",
    "text": "Tidymodels\n\n\n\n\ntidymodels.org\nTidymodels est une collection de packages pour cr√©er de mod√®les de machine learning, en gardant la logique du Tidyverse."
  },
  {
    "objectID": "slides/00 - Intro.html#r-markdown",
    "href": "slides/00 - Intro.html#r-markdown",
    "title": "01 - Introduction",
    "section": "R Markdown",
    "text": "R Markdown\n\n\nrmarkdown.rstudio.com\nR Markdown permet d‚Äô√©crire des documents avec du code int√©gr√© (extension en .Rmd).\nVa permettre de documenter et de communiquer directement nos analyses de donn√©es !\n\n\nReproductible: √Ä chaque fois qu‚Äôon g√©n√®re le document, tout est ex√©cut√© depuis le d√©but\nSyntaxe simple pour avoir des documents de qualit√©\nLe document se d√©coupe en zones de texte et blocks de code"
  },
  {
    "objectID": "slides/00 - Intro.html#r-markdown-1",
    "href": "slides/00 - Intro.html#r-markdown-1",
    "title": "01 - Introduction",
    "section": "R Markdown",
    "text": "R Markdown"
  },
  {
    "objectID": "slides/00 - Intro.html#r-markdown---aide",
    "href": "slides/00 - Intro.html#r-markdown---aide",
    "title": "01 - Introduction",
    "section": "R Markdown - Aide",
    "text": "R Markdown - Aide\n\n\nCheatsheetHelp &gt; Cheatsheet\n\n\nMarkdown Quick ReferenceHelp &gt; Markdown Quick Reference"
  },
  {
    "objectID": "slides/00 - Intro.html#les-outils-1",
    "href": "slides/00 - Intro.html#les-outils-1",
    "title": "01 - Introduction",
    "section": "Les outils",
    "text": "Les outils\n\nD√©veloppement:\n\nR\nRStudio\ntidyverse\nR Markdown\n\n\n\nGestion et collaboration:\n\nGit\nGitHub"
  },
  {
    "objectID": "slides/00 - Intro.html#git-et-github",
    "href": "slides/00 - Intro.html#git-et-github",
    "title": "01 - Introduction",
    "section": "Git et GitHub",
    "text": "Git et GitHub\n\n\n\n\n\n\n\n\nGit est un outil de gestion de version\n\nComme le track changes sur Word\n\nTr√®s populaire dans le monde de la programmation\n\n\n\n\n\n\n\n\nGitHub est un plateforme de stockage de repo Git\n\nComme un Onedrive/Dropbox pour Git\n\nNous allons essayer de l‚Äôutiliser pour‚Ä¶ tout !"
  },
  {
    "objectID": "slides/00 - Intro.html#pourquoi-la-gestion-de-version",
    "href": "slides/00 - Intro.html#pourquoi-la-gestion-de-version",
    "title": "01 - Introduction",
    "section": "Pourquoi la gestion de version ?",
    "text": "Pourquoi la gestion de version ?\n\nPhD Comics"
  },
  {
    "objectID": "slides/00 - Intro.html#fonctionnement",
    "href": "slides/00 - Intro.html#fonctionnement",
    "title": "01 - Introduction",
    "section": "Fonctionnement",
    "text": "Fonctionnement"
  },
  {
    "objectID": "slides/00 - Intro.html#mise-en-place",
    "href": "slides/00 - Intro.html#mise-en-place",
    "title": "01 - Introduction",
    "section": "Mise en place",
    "text": "Mise en place\nGit peut √™tre utilis√© depuis le terminal de commande\n\nUtilisation plus avanc√©e\nNous pouvons normalement tout faire depuis R Studio\n\nGithub:\n\nCr√©ez un compte avec votre adresse UQTR\nV√©rifiez votre adresse courriel"
  },
  {
    "objectID": "slides/00 - Intro.html#bibliographie",
    "href": "slides/00 - Intro.html#bibliographie",
    "title": "01 - Introduction",
    "section": "Bibliographie",
    "text": "Bibliographie\n\n\nKuhn, M. and Silge, J. (2022). Tidy modeling with R: A framework for modeling in the tidyverse. O‚ÄôReilly Media.\n\n\nWickham, H. and Bryan, J. (2023). R Packages: Organize, Test, Document, and Share Your Code (2nd edition). O‚ÄôReilly Media.\n\n\nWickham, H., √áetinkaya-Rundel, M. and Grolemund, G. (2023). R for Data Science (2nd ed.). O‚ÄôReilly Media, Inc.\n\n\n\n\n\n\nSFC6006 | Tim Boll√©"
  },
  {
    "objectID": "examen/examen.html",
    "href": "examen/examen.html",
    "title": "Examen",
    "section": "",
    "text": "L‚Äôexamen se compose de 3 exercices. Pour avoir acc√®s aux donn√©es et √† la feuille de r√©ponse, vous devrez utiliser GitHub et GitHub classroom.\nSur le portail de cours, acceptez l‚Äôinvitation √† rejoindre le projet GitHub Classroom pour l‚Äôexamen.\nCopiez le lien de repo personnel. Cela devrait ressember √† Examen-&lt;votre nom d'utilisateur GitHub&gt;.\nDans RStudio:\n\nFichier &gt; Nouveau Projet\nVersion Control &gt; Git\nDans Repository URL : indiquez l‚Äôadresse de repo copi√©e pr√©c√©demment\nChoisissez un nom pour le dossier qui sera cr√©√©\nChoisissez le dossier o√π cr√©er le projet\n\nCela va copier les fichiers pr√©sents sur GitHub, et les copier dans le dossier sp√©cifi√©.\nDans RStudio, vous devriez voir le fichier .Rmd list√© en bas √† droite dans la liste de fichier.\nSi vous cliquez maintenant sur le fichier .Rmd, il va apparaitre dans la zone en haut √† gauche. Vous pourrez l‚Äô√©diter et le ‚ÄúRender/Knit‚Äù pour voir le r√©sultat final.\nVeuillez noter que ce que vous √©crivez dans le fichier Rmd et ce que vous √©crivez dans la console ne communiquent pas (il s‚Äôagit de deux environnements diff√©rents). Si vous voulez utiliser la console (zone en bas √† gauche), il faut retaper les commandes du fichier.\nLe type d‚Äôoutput dans le fichier .Rmd est r√©gl√© sur github_document. Cela veut dire que lorsque vous allez knit le document, un fichier .md sera g√©n√©r√© avec votre rapport.\nC‚Äôest ce fichier .md qui sera √©valu√©. Assurez que vous le pushez bien sur Github (il faudra l‚Äôinclure dans vos commit) et que son contenu est ‚Äúpropre‚Äù. Enlevez les messages ind√©sirables ou non-utiles et assurez-vous que les graphes et images soient correctement rendue depuis GitHub."
  },
  {
    "objectID": "examen/examen.html#les-donn√©es",
    "href": "examen/examen.html#les-donn√©es",
    "title": "Examen",
    "section": "Les donn√©es",
    "text": "Les donn√©es\nPour cet exercice, nous utiliserons les donn√©es d‚Äôutilisation des v√©los en libre circulation √† Washington, D.C. pour 2011 et 2012, avec les donn√©es de m√©t√©o correspondantes. Les donn√©es sont disponibles dans le fichier data/bikeshare.csv.\nLes colonnes du jeu de donn√©es sont les suivantes:\n\ndteday: Date\nseason: Saison (1:hiver, 2:printemps, 3:√©t√©, 4:automne)\nyr: Ann√©e (0: 2011, 1:2012)\nmnth: Mois (1 to 12)\nhr: Ann√©e (0 to 23)\nholiday: Jour f√©ri√© ou non\nweekday: Jour de la semaine (0:dimanche, ‚Ä¶, 6:samedi)\nworkingday: 1 si c‚Äôest un jour ouvrable (lundi √† vendredi, hors vacances), 0 sinon\nweathersit: M√©t√©o\n\n1: Temps clair, peu de nuages, partiellement couvert\n2: Brouillard et nuageux, brouillard et partiellement nuageux, brouillard\n3: Faible neige, faible pluie et orage, faible pluie et nuageux\n4: Grosse pluie, gr√®le, temp√™te, neige et brouillard\n\ntemp: Temp√©rature normalis√©e en degr√©s Celsius (\\(t_min = -8\\) et \\(t_max = +39\\))\natemp: Temp√©rature ressentie normalis√©e en degr√©s Celsius (\\(t_min = -16\\) et \\(t_max = +50\\))\nhum: Humidit√© normalis√©e (avec comme valeur maximale 100)\nwindspeed: Vitesse du vent normalis√©e en km/h (avec comme valeur maximale 67)\ncasual: Nombre d‚Äôutilisateurs casuels\nregistered: Nombre d‚Äôutilisateurs enregistr√©s (abonnement annuel)\ncnt: Nombre total d‚Äôutilisateurs (casual + registered)"
  },
  {
    "objectID": "examen/examen.html#questions",
    "href": "examen/examen.html#questions",
    "title": "Examen",
    "section": "Questions",
    "text": "Questions\n\nQuestion 1 (5 points) - Recodez la variable season pour en faire un factor avec les niveaux suivants: ‚Äúprintemps‚Äù, ‚Äú√©t√©‚Äù, ‚Äúautomne‚Äù, ‚Äúhiver‚Äù. Assurez vous que les saisons soient dans l‚Äôordre. Recodez les variables holiday et workingday en factor √©galement avec les niveaux ‚Äúnon‚Äù et ‚Äúoui‚Äù, avec ‚Äúnon‚Äù comme premier niveau. Recodez la variable yr en factor avec les niveaux ‚Äú2011‚Äù et ‚Äú2012‚Äù. Recodez la variable weathersit en factor avec les niveaux suivants: 1 - ‚ÄúTemps clair‚Äù, 2 - ‚ÄúBrouillard‚Äù, 3 - ‚ÄúL√©g√®res pr√©cipitations‚Äù, et 4 - ‚ÄúFortes pr√©cipitations‚Äù.\n\nSi ce n‚Äôest pas d√©j√† le cas, utilisez le package lubridate pour transformer la variable dteday en une variable de type date.\n\nQuestion 2 (5 points) - Calculez les valeurs absolues pour les variables temp, atemp, hum et windspeed, en multipliant les valeurs normalis√©es par leurs valeurs minimales et maximales.\nQuestion 3 (5 points) - Assurez vous que les variables casual et registered s‚Äôadditionnent bien pour donner la variable cnt.\n\nIndice: Une possibilit√© est de cr√©er une nouvelle colonne qui contient la valeur TRUE si la somme est √©gale √† cnt et FALSE sinon. Vous pouvez ensuite utiliser cette colonne pour v√©rifier si la somme est correcte.\n\nQuestion 4 (10 points) - Recr√©ez le graphique ci-dessous. Une fois que vous avez cr√©√© la visualisation, d√©crivez en un paragraphe ce que vous pensez √™tre le point de cette visualisation.\n\n\nAnalysez le graphique et indiquez ce que vous en comprenez.\n\nQuestion 5 (10 points) - Cr√©ez un graphique montrant la relation entre le nombre de location de v√©los, le faite qu‚Äôil s‚Äôagisse d‚Äôun jour de travail ou non et la saison. Interpr√©tez votre graphique\nQuestion 6 (5 points) - S√©parez les donn√©es en un ensemble d‚Äôentra√Ænement et un ensemble de test. Utilisez 80% des donn√©es pour l‚Äôentra√Ænement et 20% pour le test. Utilisez un r√©echantillonnage par Cross-Validation sur les donn√©es d‚Äôentrainement.\nQuestion 7 (10 points) - Cr√©ez deux mod√®les de r√©gression pr√©disant le nombre total de locations de v√©los √† partir de la saison, de l‚Äôann√©e, du fait qu‚Äôil s‚Äôagisse d‚Äôun jour de travail ou non, de la m√©t√©o, de la temp√©rature, de la temp√©rature ressentie, de l‚Äôhumidit√© et de la vitesse du vent. Pour chacun des mod√®les, quelle performance est obtenue apr√®s entra√Ænement. Quel est le meilleur des deux mod√®les choisis ?\n\nIndice: Pensez √† cr√©er une recette dans laquelle vous pourrez cr√©er faire les pr√©traitement que vous jugez utiles.\n\nQuestion 8 (10 points) - Appliquez vos deux mod√®les sur les donn√©es de tests. Repr√©sentez sur un m√™me graphique les valeurs pr√©dites par chaque mod√®le en fonction des vraies valeurs."
  },
  {
    "objectID": "examen/examen.html#les-donn√©es-1",
    "href": "examen/examen.html#les-donn√©es-1",
    "title": "Examen",
    "section": "Les donn√©es",
    "text": "Les donn√©es\nPour cet exercice, nous allons utiliser les donn√©es sur les passagers du Titanic. Les donn√©es sont pr√©sentes dans le fichier data/Titanic.csv. L‚Äôobjectif est de pr√©dire si un passager a surv√©cu ou non au naufrage du Titanic.\nLes colonnes du jeu de donn√©es sont les suivantes:\n\nPassengerId: Identifiant du passager\nSurvived: Survie (0 = Non, 1 = Oui)\nPclass: Classe du passager (1 = 1√®re, 2 = 2√®me, 3 = 3√®me)\nName: Nom du passager\nSex: Sexe du passager\nAge: √Çge du passager\nSibSp: Nombre de fr√®res et soeurs / √©poux √† bord\nParch: Nombre de parents / enfants √† bord\nTicket: Num√©ro du ticket\nFare: Prix du ticket\nCabin: Num√©ro de cabine\nEmbarked: Port d‚Äôembarquement (C = Cherbourg, Q = Queenstown, S = Southampton)"
  },
  {
    "objectID": "examen/examen.html#questions-1",
    "href": "examen/examen.html#questions-1",
    "title": "Examen",
    "section": "Questions",
    "text": "Questions\n\nQuestion 9 (5 points) - Recodez la variable Pclass en factor avec les niveaux ‚Äú1√®re‚Äù, ‚Äú2√®me‚Äù et ‚Äú3√®me‚Äù. Recodez la variable Survived en factor avec les niveaux ‚ÄúNon‚Äù et ‚ÄúOui‚Äù. Recodez la variable Embarked en factor avec les niveaux ‚ÄúCherbourg‚Äù, ‚ÄúQueenstown‚Äù et ‚ÄúSouthampton‚Äù. Recodez la variable Sex en factor avec les niveaux ‚ÄúFemme‚Äù et ‚ÄúHomme‚Äù.\nQuestion 10 (10 points) - Certaines colonnes semblent avoir des valeurs manquantes. Comptez, pour chaque colonne le nombre de valeurs manquantes. Vous devriez obtenir les r√©sultats suivants:\n\n\nAge: 177 valeurs manquantes\nCabin: 687 valeurs manquantes\nEmbarked: 2 valeurs manquantes\n\nProposez une mani√®re de g√©rer les donn√©es manquantes pour les variables Cabin et Embarked.\nPour la variable Age, nous allons imputer les valeurs manquantes en utilisant la moyenne de l‚Äô√¢ge des passagers. Commencez par calculer la moyenne et la d√©viation stadard de l‚Äô√¢ge des passagers. Nous allons ensuite remplacer les valeurs manquentes par des valeurs tir√©es d‚Äôune distribution normale avec la moyenne et la d√©viation standard calcul√©es. Cr√©ez une nouvelle colonne Age_calc o√π la valeur de l‚Äô√¢ge est √©gale √† celle de Age si elle est disponible et √† celle celle calcul√©e si elle est manquante. Pour le calcul, vous pouvez utiliser la fonction rnorm pour g√©n√©rer des valeurs al√©atoires √† partir d‚Äôune distribution normale.\nHint: Si vous utilisez la fonction rnorm directement dans la fonction mutate, il n‚Äôy aura qu‚Äôun seul tirage de la distribution. Pour contourner ce probl√®me, vous pouvez utiliser la fonction map2 du package purrr pour appliquer la fonction rnorm √† chaque ligne du jeu de donn√©es. La fonction map2 prend une liste de valeurs et une fonction comme arguments. Il existe √©galement d‚Äôautres approches, vous √™tes libre d‚Äôutiliser celle que vous souhaitez.\nHint: En utilisant la fonction rnorm, vous pouvez obtenir des valeurs n√©gatives pour l‚Äô√¢ge. Remplacez ces valeurs par 0.\n\nQuestion 11 (10 points) - Combien de passagers ont surv√©cu au naufrage du Titanic? Combien de passagers n‚Äôont pas surv√©cu? Cr√©ez une visualisation repr√©sentant la survie des passagers en fonction de la classe et du sexe des passagers.\n\nQue pouvez vous en d√©duire?\n12 Question 12 (5 points) - Nous allons essayer de pr√©dire la survie des passagers en fonction des diff√©rentes variables. Pour cela, nous allons s√©parer les donn√©es en un ensemble d‚Äôentra√Ænement et un ensemble de test. Utilisez 80% des donn√©es pour l‚Äôentra√Ænement et 20% pour le test. Utilisez un r√©echantillonnage par Bootstraping sur les donn√©es d‚Äôentrainement.\n\nQuestion 13 (15 points) - Cr√©ez deux mod√®les de classification pour pr√©dire la survie des passagers en fonction de la classe, du sexe, de l‚Äô√¢ge, du nombre de fr√®res et soeurs / √©poux √† bord, du nombre de parents / enfants √† bord, du port d‚Äôembarquement et du prix du ticket. Pour chacun des mod√®les, quelle performance est obtenue apr√®s entra√Ænement. Quel est le meilleur des deux mod√®les choisis ? Repr√©sentez sur un m√™me graphique les courbes ROC des deux mod√®les.\n\nIndice: Pensez √† cr√©er une recette dans laquelle vous pourrez cr√©er faire les pr√©traitement que vous jugez utiles.\n\nQuestion 14 (10 points) - Appliquez le meilleur des mod√®les sur les donn√©es de tests. √Ä l‚Äôaide de la fonction conf_mat, qui prend comme premier argument la liste des vraies valeurs et en deuxi√®me argument la liste des valeur pr√©dites, affichez la matrice de confusion.\n\nSeriez-vous plus confiant dans la qualit√© de pr√©diction si le mod√®le pr√©dit ‚ÄúNon‚Äù (pas de survie) ou s‚Äôil pr√©dit ‚ÄúOui‚Äù (survie)."
  },
  {
    "objectID": "examen/examen.html#les-donn√©es-2",
    "href": "examen/examen.html#les-donn√©es-2",
    "title": "Examen",
    "section": "Les donn√©es",
    "text": "Les donn√©es\nPour cet exercice, nous allons utiliser des donn√©es repr√©sentant la composition chimique de morceaux de verre provenant de diff√©rentes vitres, fabriqu√©es par deux entreprises. Les donn√©es sont pr√©sentes dans le fichier data/glass.csv.\nLes colonnes du jeu de donn√©es sont les suivantes:\n\ncompany: Indique si le verre provient de l‚Äôentreprise A ou B,\npane: Indique le num√©ro de la vitre,\nfragment: indique le num√©ro de fragment pour chaque vitre,\nrep: indique le num√©ro de r√©plicat pour chaque mesure de fragment,\n\nLes colonnes suivantes repr√©sentes les mesures par LA-ICP-MS des diff√©rents composants du verre. Toutes les unit√©s sont en parties par millions (ppm).\nLes analyses de 3 fragments de verre inconnus sont √©galement fournis dans le fichier data/unknown-glass.csv.\nL‚Äôobjectif de cet exercice est de d√©terminer, si possible, pour chaque fragment:\n\nL‚Äôentreprise ayant frabriqu√© la vitre d‚Äôorigine des fragments\nLa vitre d‚Äôorigine des fragments\n\nCet exercice ce veut plus libre dans l‚Äôapproche √† suivre."
  },
  {
    "objectID": "examen/examen.html#analyse-exploratoire-20-points",
    "href": "examen/examen.html#analyse-exploratoire-20-points",
    "title": "Examen",
    "section": "Analyse exploratoire (20 points)",
    "text": "Analyse exploratoire (20 points)\nCommencez par une analyse exploratoire (Visualisations, PCA, ‚Ä¶).\n\nQuestion 15 (20 points) - √ätes-vous capable de r√©pondre aux questions pos√©es ?\n\nSi oui, quelle confiance avez vous dans vos conclusions ?"
  },
  {
    "objectID": "examen/examen.html#classification-20-points",
    "href": "examen/examen.html#classification-20-points",
    "title": "Examen",
    "section": "Classification (20 points)",
    "text": "Classification (20 points)\nUtilisez ensuite un mod√®le de classification.\n\nQuestion 16 (20 points)√ätes-vous capable de r√©pondre aux questions pos√©es ?\n\nSi oui, quelle confiance avez vous dans vos conclusions ?\nBonus (10 points): Pour la question concernant l‚Äôentreprise d‚Äôorigine, calculez le LR pour un des fragments inconnu."
  },
  {
    "objectID": "labs/Semaine2.html",
    "href": "labs/Semaine2.html",
    "title": "Semaine 2 - Machine Learning",
    "section": "",
    "text": "L‚Äôobjectif de ce lab est de nous familiariser avec la logique derri√®re le machine learning en utilisant la suite de package tidymodels.\nPour cela, nous allons travailler sur un jeu de donn√©es qui contient des informations sur des maisons √† vendre dans la ville de Ames, Iowa, USA. Nous allons notament chercher √† pr√©dire le prix de vente des maisons en fonction des diff√©rentes caract√©ristiques."
  },
  {
    "objectID": "labs/Semaine2.html#chargement-des-donn√©es",
    "href": "labs/Semaine2.html#chargement-des-donn√©es",
    "title": "Semaine 2 - Machine Learning",
    "section": "Chargement des donn√©es",
    "text": "Chargement des donn√©es\n\ndata(ames, package = \"modeldata\")\n\ndim(ames)\n\n[1] 2930   74\n\n\nNous pouvons jeter un coup d‚Äôoeil aux donn√©es:\n\nglimpse(ames)\n\nRows: 2,930\nColumns: 74\n$ MS_SubClass        &lt;fct&gt; One_Story_1946_and_Newer_All_Styles, One_Story_1946‚Ä¶\n$ MS_Zoning          &lt;fct&gt; Residential_Low_Density, Residential_High_Density, ‚Ä¶\n$ Lot_Frontage       &lt;dbl&gt; 141, 80, 81, 93, 74, 78, 41, 43, 39, 60, 75, 0, 63,‚Ä¶\n$ Lot_Area           &lt;int&gt; 31770, 11622, 14267, 11160, 13830, 9978, 4920, 5005‚Ä¶\n$ Street             &lt;fct&gt; Pave, Pave, Pave, Pave, Pave, Pave, Pave, Pave, Pav‚Ä¶\n$ Alley              &lt;fct&gt; No_Alley_Access, No_Alley_Access, No_Alley_Access, ‚Ä¶\n$ Lot_Shape          &lt;fct&gt; Slightly_Irregular, Regular, Slightly_Irregular, Re‚Ä¶\n$ Land_Contour       &lt;fct&gt; Lvl, Lvl, Lvl, Lvl, Lvl, Lvl, Lvl, HLS, Lvl, Lvl, L‚Ä¶\n$ Utilities          &lt;fct&gt; AllPub, AllPub, AllPub, AllPub, AllPub, AllPub, All‚Ä¶\n$ Lot_Config         &lt;fct&gt; Corner, Inside, Corner, Corner, Inside, Inside, Ins‚Ä¶\n$ Land_Slope         &lt;fct&gt; Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, Gtl, G‚Ä¶\n$ Neighborhood       &lt;fct&gt; North_Ames, North_Ames, North_Ames, North_Ames, Gil‚Ä¶\n$ Condition_1        &lt;fct&gt; Norm, Feedr, Norm, Norm, Norm, Norm, Norm, Norm, No‚Ä¶\n$ Condition_2        &lt;fct&gt; Norm, Norm, Norm, Norm, Norm, Norm, Norm, Norm, Nor‚Ä¶\n$ Bldg_Type          &lt;fct&gt; OneFam, OneFam, OneFam, OneFam, OneFam, OneFam, Twn‚Ä¶\n$ House_Style        &lt;fct&gt; One_Story, One_Story, One_Story, One_Story, Two_Sto‚Ä¶\n$ Overall_Cond       &lt;fct&gt; Average, Above_Average, Above_Average, Average, Ave‚Ä¶\n$ Year_Built         &lt;int&gt; 1960, 1961, 1958, 1968, 1997, 1998, 2001, 1992, 199‚Ä¶\n$ Year_Remod_Add     &lt;int&gt; 1960, 1961, 1958, 1968, 1998, 1998, 2001, 1992, 199‚Ä¶\n$ Roof_Style         &lt;fct&gt; Hip, Gable, Hip, Hip, Gable, Gable, Gable, Gable, G‚Ä¶\n$ Roof_Matl          &lt;fct&gt; CompShg, CompShg, CompShg, CompShg, CompShg, CompSh‚Ä¶\n$ Exterior_1st       &lt;fct&gt; BrkFace, VinylSd, Wd Sdng, BrkFace, VinylSd, VinylS‚Ä¶\n$ Exterior_2nd       &lt;fct&gt; Plywood, VinylSd, Wd Sdng, BrkFace, VinylSd, VinylS‚Ä¶\n$ Mas_Vnr_Type       &lt;fct&gt; Stone, None, BrkFace, None, None, BrkFace, None, No‚Ä¶\n$ Mas_Vnr_Area       &lt;dbl&gt; 112, 0, 108, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6‚Ä¶\n$ Exter_Cond         &lt;fct&gt; Typical, Typical, Typical, Typical, Typical, Typica‚Ä¶\n$ Foundation         &lt;fct&gt; CBlock, CBlock, CBlock, CBlock, PConc, PConc, PConc‚Ä¶\n$ Bsmt_Cond          &lt;fct&gt; Good, Typical, Typical, Typical, Typical, Typical, ‚Ä¶\n$ Bsmt_Exposure      &lt;fct&gt; Gd, No, No, No, No, No, Mn, No, No, No, No, No, No,‚Ä¶\n$ BsmtFin_Type_1     &lt;fct&gt; BLQ, Rec, ALQ, ALQ, GLQ, GLQ, GLQ, ALQ, GLQ, Unf, U‚Ä¶\n$ BsmtFin_SF_1       &lt;dbl&gt; 2, 6, 1, 1, 3, 3, 3, 1, 3, 7, 7, 1, 7, 3, 3, 1, 3, ‚Ä¶\n$ BsmtFin_Type_2     &lt;fct&gt; Unf, LwQ, Unf, Unf, Unf, Unf, Unf, Unf, Unf, Unf, U‚Ä¶\n$ BsmtFin_SF_2       &lt;dbl&gt; 0, 144, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1120, 0‚Ä¶\n$ Bsmt_Unf_SF        &lt;dbl&gt; 441, 270, 406, 1045, 137, 324, 722, 1017, 415, 994,‚Ä¶\n$ Total_Bsmt_SF      &lt;dbl&gt; 1080, 882, 1329, 2110, 928, 926, 1338, 1280, 1595, ‚Ä¶\n$ Heating            &lt;fct&gt; GasA, GasA, GasA, GasA, GasA, GasA, GasA, GasA, Gas‚Ä¶\n$ Heating_QC         &lt;fct&gt; Fair, Typical, Typical, Excellent, Good, Excellent,‚Ä¶\n$ Central_Air        &lt;fct&gt; Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, ‚Ä¶\n$ Electrical         &lt;fct&gt; SBrkr, SBrkr, SBrkr, SBrkr, SBrkr, SBrkr, SBrkr, SB‚Ä¶\n$ First_Flr_SF       &lt;int&gt; 1656, 896, 1329, 2110, 928, 926, 1338, 1280, 1616, ‚Ä¶\n$ Second_Flr_SF      &lt;int&gt; 0, 0, 0, 0, 701, 678, 0, 0, 0, 776, 892, 0, 676, 0,‚Ä¶\n$ Gr_Liv_Area        &lt;int&gt; 1656, 896, 1329, 2110, 1629, 1604, 1338, 1280, 1616‚Ä¶\n$ Bsmt_Full_Bath     &lt;dbl&gt; 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, ‚Ä¶\n$ Bsmt_Half_Bath     &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ‚Ä¶\n$ Full_Bath          &lt;int&gt; 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 2, ‚Ä¶\n$ Half_Bath          &lt;int&gt; 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, ‚Ä¶\n$ Bedroom_AbvGr      &lt;int&gt; 3, 2, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 2, 1, 4, 4, ‚Ä¶\n$ Kitchen_AbvGr      &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ‚Ä¶\n$ TotRms_AbvGrd      &lt;int&gt; 7, 5, 6, 8, 6, 7, 6, 5, 5, 7, 7, 6, 7, 5, 4, 12, 8,‚Ä¶\n$ Functional         &lt;fct&gt; Typ, Typ, Typ, Typ, Typ, Typ, Typ, Typ, Typ, Typ, T‚Ä¶\n$ Fireplaces         &lt;int&gt; 2, 0, 0, 2, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, ‚Ä¶\n$ Garage_Type        &lt;fct&gt; Attchd, Attchd, Attchd, Attchd, Attchd, Attchd, Att‚Ä¶\n$ Garage_Finish      &lt;fct&gt; Fin, Unf, Unf, Fin, Fin, Fin, Fin, RFn, RFn, Fin, F‚Ä¶\n$ Garage_Cars        &lt;dbl&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, ‚Ä¶\n$ Garage_Area        &lt;dbl&gt; 528, 730, 312, 522, 482, 470, 582, 506, 608, 442, 4‚Ä¶\n$ Garage_Cond        &lt;fct&gt; Typical, Typical, Typical, Typical, Typical, Typica‚Ä¶\n$ Paved_Drive        &lt;fct&gt; Partial_Pavement, Paved, Paved, Paved, Paved, Paved‚Ä¶\n$ Wood_Deck_SF       &lt;int&gt; 210, 140, 393, 0, 212, 360, 0, 0, 237, 140, 157, 48‚Ä¶\n$ Open_Porch_SF      &lt;int&gt; 62, 0, 36, 0, 34, 36, 0, 82, 152, 60, 84, 21, 75, 0‚Ä¶\n$ Enclosed_Porch     &lt;int&gt; 0, 0, 0, 0, 0, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\n$ Three_season_porch &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ‚Ä¶\n$ Screen_Porch       &lt;int&gt; 0, 120, 0, 0, 0, 0, 0, 144, 0, 0, 0, 0, 0, 0, 140, ‚Ä¶\n$ Pool_Area          &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ‚Ä¶\n$ Pool_QC            &lt;fct&gt; No_Pool, No_Pool, No_Pool, No_Pool, No_Pool, No_Poo‚Ä¶\n$ Fence              &lt;fct&gt; No_Fence, Minimum_Privacy, No_Fence, No_Fence, Mini‚Ä¶\n$ Misc_Feature       &lt;fct&gt; None, None, Gar2, None, None, None, None, None, Non‚Ä¶\n$ Misc_Val           &lt;int&gt; 0, 0, 12500, 0, 0, 0, 0, 0, 0, 0, 0, 500, 0, 0, 0, ‚Ä¶\n$ Mo_Sold            &lt;int&gt; 5, 6, 6, 4, 3, 6, 4, 1, 3, 6, 4, 3, 5, 2, 6, 6, 6, ‚Ä¶\n$ Year_Sold          &lt;int&gt; 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 201‚Ä¶\n$ Sale_Type          &lt;fct&gt; WD , WD , WD , WD , WD , WD , WD , WD , WD , WD , W‚Ä¶\n$ Sale_Condition     &lt;fct&gt; Normal, Normal, Normal, Normal, Normal, Normal, Nor‚Ä¶\n$ Sale_Price         &lt;int&gt; 215000, 105000, 172000, 244000, 189900, 195500, 213‚Ä¶\n$ Longitude          &lt;dbl&gt; -93.61975, -93.61976, -93.61939, -93.61732, -93.638‚Ä¶\n$ Latitude           &lt;dbl&gt; 42.05403, 42.05301, 42.05266, 42.05125, 42.06090, 4‚Ä¶\n\n\nQuestion 1: Faites un historgramme pour repr√©senter les prix de vente des maisons. Faites un deuxi√®me histogramme en utilisant une √©chelle logarithmique sur le prix."
  },
  {
    "objectID": "labs/Semaine2.html#construction-du-mod√®le",
    "href": "labs/Semaine2.html#construction-du-mod√®le",
    "title": "Semaine 2 - Machine Learning",
    "section": "Construction du mod√®le",
    "text": "Construction du mod√®le\nIl existe de nombreux packages et fonctions pour faire appel √† toute une collection de mod√®les. Tidymodels propose une interface unique √† de nombreux mod√®les. Cela permet d‚Äôinteragir de mani√®re ‚Äúunique‚Äù avec les mod√®les et leurs r√©sultats.\nL‚Äôapproche de base pour un mod√®le consiste √†:\n\nSp√©cifier le mod√®le math√©matique souhait√©.\nSp√©cifier le ‚Äúmoteur‚Äù ( engine ) √† utiliser pour le mod√®le. Souvent, cela correspond au package dans lequel on retrouve la fonction.\nDans certains cas, pr√©ciser le mode dans lequel le mod√®le va √™tre utilis√©. De base, si l‚Äôon travaille des donn√©es num√©riques, le mode sera Regression et si les donn√©es sont cat√©goriques, il sera Classification. Il est possible de le pr√©ciser explicitement.\n\nPar exemple, pour une regression lin√©aire, nous pourrions avoir:\n\nlinear_reg() %&gt;%\n  set_engine(\"lm\")\n\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\nlinear_reg() %&gt;%\n  set_engine(\"glmnet\")\n\nLinear Regression Model Specification (regression)\n\nComputational engine: glmnet \n\n\nNous allons commencer avec une simple regression lin√©aire (engine : \"lm\"). Nous pouvons d√©finir le mod√®le:\n\nlm_model &lt;- linear_reg() %&gt;%\n  set_engine(\"lm\")\n\nNous pourrions √©galement utiliser un Random Forest. Pour cela, nous allons utiliser celui du package \"ranger\" (que vous devrez probablement installer). Il est possible que le mod√®le que nous souhaitons utiliser ait besoin de param√®tres √† pr√©ciser. Nous pouvons le faire √† la d√©finition du mod√®le:\n\nrf_model &lt;- rand_forest(trees = 1000, min_n = 5) %&gt;%\n  set_engine(\"ranger\") %&gt;%\n  set_mode(\"regression\")\n\nIci, nous avons pr√©ciser directement les arguments trees et min_n. Nous verrons la semaine prochaine comment tester plusieurs valeurs pour ces hyperparam√®tres. Nous avons √©galement pr√©cis√© que nous souhaitons faire du Random Forest en mode r√©gession.\n√Ä tout moment, vous pouvez aller consulter la doc des fonctions sur le site de tidymodels ou avec la commande ?rand_forest ou ?linear_reg.\nLa liste des diff√©rents mod√®les disponibles peut √™tre consult√©e dans la documentation du package parsnip (partie de tidymodels)"
  },
  {
    "objectID": "labs/Semaine2.html#entra√Ænement-du-mod√®le",
    "href": "labs/Semaine2.html#entra√Ænement-du-mod√®le",
    "title": "Semaine 2 - Machine Learning",
    "section": "Entra√Ænement du mod√®le",
    "text": "Entra√Ænement du mod√®le\nPour entra√Æner le mod√®le, il suffit de le fit sur des donn√©es. Il faut en revanche indiquer via une formule ce que nous souhaitons mod√©liser.\nLa forme g√©n√©rale pour les formules permet d‚Äôindiquer la variable expliqu√©e ( response ou outcome ) en fonction des variables explicatives ( predictor ). En R, les formules sont √©crite de la mani√®re var_expliquee ~ var_explicative. Pour utiliser toutes les variables comme explicatives, on peut simplement √©crire var_expliquee ~ .. Pour en savoir plus sur les formules et les possibilit√©s, vous pouvez lire ce chapitre (Kuhn and Silge, 2022).\nPar exemple, si nous voulons pr√©dire le prix en fonction de la localisation de la maison, nous pouvons indiquer:\n\nlm_fit &lt;- lm_model %&gt;%\n  fit(Sale_Price ~ Longitude + Latitude, data= ames_train)\n\nL‚Äôargument data indique sur quelles donn√©es faire le fit.\nNous pouvons, √©galement entrainer notre mod√®le de Random Forest:\n\nrf_fit &lt;- rf_model %&gt;%\n  fit(Sale_Price ~ Longitude + Latitude, data= ames_train)"
  },
  {
    "objectID": "labs/Semaine2.html#r√©sultats-de-lentrainement",
    "href": "labs/Semaine2.html#r√©sultats-de-lentrainement",
    "title": "Semaine 2 - Machine Learning",
    "section": "R√©sultats de l‚Äôentrainement",
    "text": "R√©sultats de l‚Äôentrainement\nPour afficher les r√©sultats de l‚Äôentra√Ænement, il y a plusieurs mani√®res de faire, selon que nous voulons les afficher ou les visualiser.\nUne premi√®re approche consiste √† extraire les param√®tres de fit:\n\nlm_fit %&gt;% extract_fit_engine()\n\n\nCall:\nstats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n -133779792      -823798      1351690  \n\nrf_fit %&gt;% extract_fit_engine()\n\nRanger result\n\nCall:\n ranger::ranger(x = maybe_data_frame(x), y = y, num.trees = ~1000,      min.node.size = min_rows(~5, x), num.threads = 1, verbose = FALSE,      seed = sample.int(10^5, 1)) \n\nType:                             Regression \nNumber of trees:                  1000 \nSample size:                      2197 \nNumber of independent variables:  2 \nMtry:                             1 \nTarget node size:                 5 \nVariable importance mode:         none \nSplitrule:                        variance \nOOB prediction error (MSE):       1842151707 \nR squared (OOB):                  0.7129196 \n\n\nFaite attention que certaines m√©thodes ne fonctionnent que pour les r√©sultats de certains mod√®les. Par exemple, la fonction tidy() du package broom (inclus dans tidymodels) permet d‚Äôafficher certains r√©sultats pour le r√©sultats de la r√©grssion lin√©aire mais pas ceux du Random Forest.\n\ntidy(lm_fit)\n\n# A tibble: 3 √ó 5\n  term           estimate std.error statistic  p.value\n  &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 (Intercept) -133779792.  6803737.     -19.7 2.08e-79\n2 Longitude      -823798.    60860.     -13.5 3.75e-40\n3 Latitude       1351690.    84586.      16.0 1.85e-54\n\n\nDans ces cas, il ne faut pas h√©siter √† rechercher un peu dans la doc la meilleure mani√®re d‚Äôafficher les r√©sultats.\nIl est d√©j√† possible √† cette √©tape d‚Äôavoir une id√©e de la performance du mod√®le, sur les donn√©es d‚Äôentrainement. Vous l‚Äôavez peut-√™tre vu pour le Random Forest, quand nous affichons les d√©tails du mod√®le, un \\(R^2\\) est indiqu√©. Pour les r√©sultats de la r√©gression lin√©aire, on peut utiliser glance()\n\nlm_fit %&gt;% glance()\n\n# A tibble: 1 √ó 12\n  r.squared adj.r.squared  sigma statistic  p.value    df  logLik    AIC    BIC\n      &lt;dbl&gt;         &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1     0.163         0.162 73331.      213. 2.38e-85     2 -27728. 55465. 55487.\n# ‚Ñπ 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;"
  },
  {
    "objectID": "labs/Semaine2.html#faire-des-pr√©dictions",
    "href": "labs/Semaine2.html#faire-des-pr√©dictions",
    "title": "Semaine 2 - Machine Learning",
    "section": "Faire des pr√©dictions",
    "text": "Faire des pr√©dictions\nL‚Äôid√©e de cette √©tape est d‚Äôappliquer le mod√®le entra√Æn√© sur des donn√©es, en g√©n√©rale celles de tests. De base, cela se fait via la fonction predict:\n\nlm_fit %&gt;% predict(new_data = ames_test)\n\n# A tibble: 733 √ó 1\n     .pred\n     &lt;dbl&gt;\n 1 213054.\n 2 202464.\n 3 196577.\n 4 227633.\n 5 225029.\n 6 224060.\n 7 221036.\n 8 217686.\n 9 218026.\n10 215263.\n# ‚Ñπ 723 more rows\n\n\nComme vous le voyez, nous obtenons une liste de valeur pr√©dite. La colonne contenant celles-ci s‚Äôappelle .pred.\nIl est souvent utile coller les pr√©dictions au tableau des donn√©es de test:\n\nlm_pred &lt;- lm_fit %&gt;%\n  predict(new_data = ames_test) %&gt;%\n  bind_cols(ames_test)\n\nCette fois, nous obtenons un tableau complet, avec les donn√©es r√©elles et les donn√©es pr√©dites. Nous pouvons par exemple les visualiser:\n\nlm_pred %&gt;%\n  ggplot(aes(x=.pred, y=Sale_Price)) +\n  geom_point(alpha = .5)\n\n\n\n\n\n\n\n\nQuestion 2: Faites de m√™me pour le mod√®le Random Forest ! Que constatez vous ?"
  },
  {
    "objectID": "labs/Semaine2.html#les-donn√©es",
    "href": "labs/Semaine2.html#les-donn√©es",
    "title": "Semaine 2 - Machine Learning",
    "section": "Les donn√©es",
    "text": "Les donn√©es\nNous allons travailler sur un jeu de donn√©es qui contient des informations sur des r√©servations d‚Äôh√¥tels. Nous allons essayer de pr√©dire si une r√©servation avait des enfants. Pour cela, nous allons utiliser des m√©thodes de classification.\n\nlibrary(tidymodels)\nlibrary(readr)\n\nhotels &lt;- \n  read_csv(\"https://tidymodels.org/start/case-study/hotels.csv\") %&gt;%\n  mutate(across(where(is.character), as.factor))\n\ndim(hotels)\n\n[1] 50000    23\n\n\nQuestion 4: D√©terminez la proportion de r√©servations qui ont des enfants."
  },
  {
    "objectID": "labs/Semaine2.html#s√©paration-des-donn√©es-1",
    "href": "labs/Semaine2.html#s√©paration-des-donn√©es-1",
    "title": "Semaine 2 - Machine Learning",
    "section": "S√©paration des donn√©es",
    "text": "S√©paration des donn√©es\nQuestion 5: Commencez par fixer un seed et puis divisez les donn√©es en un ensemble d‚Äôentra√Ænement et un ensemble de test. Utilisez 75% des donn√©es pour l‚Äôentra√Ænement. Assurez-vous que les proportions de r√©servations avec enfants sont les m√™mes dans les deux ensembles."
  },
  {
    "objectID": "labs/Semaine2.html#premier-mod√®le-r√©gression-logistique",
    "href": "labs/Semaine2.html#premier-mod√®le-r√©gression-logistique",
    "title": "Semaine 2 - Machine Learning",
    "section": "Premier mod√®le: R√©gression logistique",
    "text": "Premier mod√®le: R√©gression logistique\n\nChoix du mod√®le\nQuestion 6: Configurez un mod√®le de regression logistique en utilisant la fonction logistic_reg(). Utilisez la fonction set_engine() pour sp√©cifier que vous voulez utiliser la fonction glm(). Nous travaillons en mode Classification.\n\n\nRecette\nQuestion 7: Cr√©ez une recette pour le mod√®le en utilisant la fonction recipe().\nNous allons utiliser les recettes suivantes:\n\nstep_date(): pour cr√©er les variable de l‚Äôann√©e, du mois et du jour de la semaine\nstep_holiday(): pour cr√©er une variable qui indique si la r√©servation a √©t√© faite pendant une p√©riode de vacances. Nous vous avons fourni une liste de vacances dans le fichier de r√©ponse (voir ci-dessous). Vous pouvez indiquer d‚Äôutiliser cette liste avec step_holiday(arrival_date, holidays = holidays)\nstep_rm(): pour supprimer les variables arrival_date\n\nNous allons √©galement transformer les variables cat√©gorielles en dummy variables et les variables num√©riques en variables centr√©es et r√©duites.\n\nstep_dummy() pour convertir les variables cat√©gorielles (all_nominal_predictors()) en variables binaires\nstep_zv() permet d‚Äôenlever les variables qui ne contiennent qu‚Äôune unique valeur (all_predictors())\nstep_normalize() pour centrer et r√©duire les variables num√©riques (all_numeric_predictors())\n\nPour step_holiday, vous pouvez utiliser la liste suivante:\n\nholidays &lt;- c(\"AllSouls\", \"AshWednesday\", \"ChristmasEve\", \"Easter\", \n              \"ChristmasDay\", \"GoodFriday\", \"NewYearsDay\", \"PalmSunday\")\n\n\n\nCr√©ation du workflow\nQuestion 8: Cr√©ez un workflow en utilisant la fonction workflow(). Ajoutez-y la recette et le mod√®le.\n\n\nEntra√Ænement et Pr√©diction\nQuestion 9: Fittez votre mod√®le\nQuestion 10: Pr√©disez le mod√®le en utilisant le bloc de code ci-dessous. Expliquez ce qu‚Äôil fait !\n\nlr_pred &lt;- predict(lr_fit, hotel_test) %&gt;%\n  bind_cols(predict(lr_fit, hotel_test, type = \"prob\")) %&gt;%\n  bind_cols(hotel_test %&gt;% select(children))\n\n\n\n√âvaluation du mod√®le\nNous allons g√©n√©rer une courbe ROC pour √©valuer le mod√®le\n\nlr_auc &lt;- lr_pred %&gt;%\n  roc_curve(children, .pred_children) %&gt;%\n  mutate(model = \"Logistic Regression\")\n\nlr_auc %&gt;% autoplot()\n\nNous pouvons √©galement calculer directement l‚Äôaire sous la courve en faisant appelle √† yardstick et √† la fonction roc_auc\n\nlr_pred %&gt;%\n  roc_auc(children, .pred_children)"
  },
  {
    "objectID": "labs/Semaine2.html#deuxi√®me-mod√®le-random-forest",
    "href": "labs/Semaine2.html#deuxi√®me-mod√®le-random-forest",
    "title": "Semaine 2 - Machine Learning",
    "section": "Deuxi√®me mod√®le: Random Forest",
    "text": "Deuxi√®me mod√®le: Random Forest\nCette fois, nous allons faire de la classification avec Random Forest. Vous pouvez utiliser le mod√®le suivant:\n\ncores &lt;- parallel::detectCores() # Nombre de coeur √† disposition pour le calcul\n\nrf_mod &lt;- \n  rand_forest(trees = 1000) %&gt;% \n  set_engine(\"ranger\", num.threads = cores) %&gt;% \n  set_mode(\"classification\")\n\nQuestion 11: Reproduisez les √©tapes de pr√©processing, d‚Äôentrainement et de pr√©diction avec ce nouveau model. Pour le preprocessing, utilisez simplement les √©tapes:\n\nstep_date() avec la date d‚Äôarriv√©e\nstep_holiday() pour d√©terminer si la date d‚Äôarriv√©e correspond √† une p√©riode de vacance\nstep_rm() pour retirer la date d‚Äôarriv√©e (nous voulons simplement garder l‚Äôindication de si cela correspond √† une p√©riode de vacances)\n\nQuestion 12: Calculez l‚Äôaire sous la courbe ROC. Comparez par rapport √† celle obtenu pour le premier mod√®le.\nQuestion 13: Faite un graphique contenant les courbes ROC pour les deux mod√®les. Pour cela, inspirez du code fourni pour la regression logistique pour obtenir un tableau similaire √† lr_auc, mais contenant les valeurs obtenues avec Random Forest, en indiquant ‚ÄúRandom Forest‚Äù dans la colonne model. Combinez, √† l‚Äôaide de bind_rows() les deux tableaux et utilisez ggplot pour afficher les deux courbes sur un m√™me grahique en changeant la couleur selon le mod√®le."
  }
]